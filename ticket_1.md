## Билет 1.

### 1. Какие методы есть у класса Object?

У класса Object есть следующие методы:
- hashCode() - определяет хэш-код объекта
- equals() - определяет равен ли один объект другому.
- wait() - останавливает поток и ждет когда другой подаст ему сигнал о возобновлении работы.
- notify() - уведомляет определенный поток о возможности возобновления прерванной работы.
- notifyAll() - уведомляет все потоки о возможности возобновления прерванной работы.
- clone() - создает новые объект, не отличающийся от исходного.
- toString() - возвращает строку, описывающую объект.
- getClass() - определяет какому классу принадлежит исходный объект
- finalize() - вызывается перед удалением неиспользуемого объекта.

### 2. Что из себя представляет Spring Framework?

Spring Framework - фреймворк с открытым исходным кодом для Java-платформы. Этот фреймворк преимущественно используется для разработки backend части приложений.
Spring может быть рассмотрен как коллекция меньших фреймворков или фреймворков во фреймворке. Большинство этих фреймворков может работать независимо друг от друга, однако они обеспечивают большую функциональность при совместном их использовании.  

Центральной частью Spring является контейнер Inversion of Control, который предоставляет средства конфигурирования и управления объектами Java с помощью рефлексии. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.

Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно конфигурирование контейнера осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также есть возможность "по старинке" загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.

Объекты могут быть получены одним из двух способов:  
- Поиск зависимости — шаблон проектирования, в котором вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определённым именем или определённого типа.
- Внедрение зависимости — шаблон проектирования, в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора, свойства или фабричного метода.

Большую популярность приобретает модуль Spring Boot, потому что с ним разработка приложений стала намного легче и автоматизированнее. Программисту не приходится писать много лишнего кода, как при использовании чистого Spring Framework. Spring Boot удобнее при построении микросервисов и он также сочетается со всеми остальными модулями Spring.

### 3. Каково назначение методов equals() и hashCode()? Что будет если не переопределяя hashCode() переопределить equals()?

Метод hashCode() используется для генерации хеш-кода определенного объекта Java: задаются поля по которым будет генериться хеш-код и затем объекты будут сравниваться по этому же самому хеш-коду, но для этого необходимо еще и переопределить метод equals(), иначе этот метод будет сравнивать значения не по значениям, а по ссылкам.  

Допустим, мы переопределили только метод equals(), тогда с точки зрения метода equals() одинаковые объекты могут быть равно, но не с точки зрения hashCode(). И таким образом, помещая объект в некоторую хеш-таблицу мы рискуем не получить его обратно по ключу.  

Может быть ситуация что хеш-коды разных объектов совпадают, данное явление называется `коллизией`

### 4. Что такое Аспектно-ориентированное программирование (АОП)?

Аспектно-ориентированное программирование - парадигма программирования, отделяющая сквозную логику (служебные части, такие как логи, аудиты и т. п.) от бизнес-логики приложения. 

У использования АОП подхода к логированию есть несколько преимуществ по сравнению с ручной вставкой логирования:

- Код для логирования легко внедрять и удалять: всего-то нужно добавить или удалить пару конфигураций некоторого аспекта.
- Весь исходный код для логирования хранится в одном месте и не нужно находить вручную все места использования.
- Код, предназначенный для логирования, можно добавить в любое место, будь то уже написанные методы и классы или же новый функционал. Это уменьшает количество ошибок разработчика.
- Также при удалении аспекта из конфигурации конструкции можно быть абсолютно уверенным, что весь код трассировки удален и ничего не пропущено.
- Аспекты — это вынесенный отдельно код, который можно многократно переиспользовать и улучшать.

Совет (advice) — это дополнительная логика, код, который вызывается из точки соединения.  

Возможные виды советов:
- Перед (Before) — советы данного типа запускаются перед выполнением целевых методов — точек соединения. При использовании аспектов в виде классов мы берем @Before аннотацию, чтобы пометить тип совета как идущий перед.
- После (After) — советы, которые выполняются после завершения выполнения методов — точек соединения, как в обычных случаях, так и при бросании исключения.
При использовании аспектов в виде классов мы можем использовать @After аннотацию для указания, что это совет, идущий после.
- После возврата (After Returning) — данные советы выполняются только в том случае, когда целевой метод отрабатывает нормально, без ошибок.
Когда аспекты представлены в виде классов, мы можем использовать аннотацию @AfterReturning, чтобы пометить совет как выполняемый после успешного завершения.
- После бросания (After Throwing) — данный вид советов предназначен для тех случаев, когда метод, то есть точка соединения выдает исключение. Мы можем использовать этот совет для некой обработки неудачного выполнения (к примеру, для отката всей транзакции или логирования с необходимым уровнем трассировки).
Для аспектов-классов аннотация @AfterThrowing используется, чтобы указать, что этот совет используется при после броска исключения.
- Вокруг (Around) — пожалуй, один из самых важных видов советов, который окружает метод, то есть — точку соединения, с помощью которого мы можем, к примеру, выбрать, выполнять данный метод точки соединения или нет.
Можно написать код совета, который будет выполняться до и после выполнения метода точки соединения.
В обязанности around advice входит вызов метода точки соединения и возвращение значений, если метод что-то возвращает. То есть в этом совете можно попросту сымитировать работу целевого метода, не вызывая его, и в качестве результата вернуть что-то свое.
При аспектах в виде классов используем @Around аннотацию для создания советов, оборачивающих точку соединения.  

Точка соединения (join point) — точка в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет. Иначе говоря, это некоторое регулярное выражение, с помощью которого и находятся места для внедрения кода (места для применения советов).  

Срез (pointcut) — набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному совету.  

Аспект (aspect) — модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определенных некоторым срезом. Иными словами, это комбинация советов и точек соединения.  

### 5. Чем микросервисная архитектура отличается от монолитной? Назовите преимущества и недостатки обеих архитектур.

Монолитная архитектура — это традиционная модель разработки программного обеспечения, в которой одна база кода используется для выполнения нескольких бизнес-функций. Все программные компоненты монолитной системы взаимозависимы из-за использования встроенных механизмов обмена данными внутри системы. Модификация монолитной архитектуры возможна лишь частично и занимает много времени, поскольку даже небольшие изменения затрагивают большие области базы кода. Напротив, архитектурный подход на основе микросервисов подразумевает, что программное обеспечение состоит из небольших независимых компонентов (сервисов). Каждый сервис выполняет одну функцию и взаимодействует с другими сервисами через четко определенные интерфейсы. Поскольку они работают независимо, вы можете обновлять, изменять, развертывать или масштабировать каждую службу отдельно по мере необходимости.  

Монолитные приложения обычно состоят из пользовательского интерфейса на стороне клиента, базы данных и серверного приложения. Разработчики создают все эти модули в одной базе кода.  

В распределенной архитектуре каждый микросервис выполняет одну функцию или один элемент бизнес-логики. Микросервисы взаимодействуют друг с другом через API, а не через встроенные механизмы языка программирования.  

Преимущества монолитов:
- Быстрая реализация
- Простое развертывание
- Простая балансировка


Недостатки монолитов:
- Экспоненциальный рост сложности
- Трудно вносить изменения
- Медленное развертывание
- Дорогое масштабирование
- При отказе одного компонента все приложение падает

Преимущества микросервисов:
- Легко вносить изменения и легко разобраться в коде
- Хорошая отказоустойчивость: при отказе одного микросервиса приложение продолжит свою работу
- Масштабируемость
- Не экспоненциальный рост сложности

Недостатки микросервисов:
- Интеграционное тестирование сложнее чем у монолитов
- Сложное развертывание
- Может требовать больше ресурсов
- Сложная балансировка
