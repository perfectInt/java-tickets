## Билет 3.

### 1. Что такое сериализация и десериализация? Опишите процесс сериализации/десериализации.

**Сериализация (Serialization)** - процесс преобразования структуры данных в линейную последовательность байтов для дальнейшей передачи или сохранения. Соответственно, десериализация - процесс восстановления данных после сериализации.

При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:
- запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
- рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
- запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
- рекурсивную запись объектов, которые являются полями сериализуемого объекта.

При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.

Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.

### 2. Для чего нужны методы wait(), notify(), notifyAll()?

Все методы используются в механизме многопоточности Java. Их действие во многом объясняется их дословным переводом.  

Метод wait() вызывается нитью в синхронизированном блоке у объекта-монитора. В результате вызова нить,которая его осуществила становиться в режим ожидания и отпускает мютекс объекта-монитора. Снять с паузы её могут другие нити,зашедшие в синхронизированный блок и вызвавшие методы notify() или notifyAll() на объекте-мониторе. Есть ещё метод wait(long timeout) с таймаутом, который пробуждает нить по истечении времени,переданного в него,если до этого не были вызваны notify() или notifyAll().  

Метод notify() вызывается у монитора и снимает с wait’а одну случайную нить. notifyAll() снимает с паузы все заснувшие нити.

### 3. Что такое "нормализация" и "денормализация"? Какие существуют нормальные формы?

**Нормализация** - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).

Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.  

**Денормализация базы данных** — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных.  

Существуют следующие нормальные формы:
- **Первая нормальная форма (1NF)** - Отношение находится в 1NF, если значения всех его атрибутов атомарны (неделимы).
- **Вторая нормальная форма (2NF)** - Отношение находится в 2NF, если оно находится в 1NF, и при этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части.
- **Третья нормальная форма (3NF)** - Отношение находится в 3NF, если оно находится в 2NF и все неключевые атрибуты не зависят друг от друга.
- **Четвёртая нормальная форма (4NF)** - Отношение находится в 4NF , если оно находится в 3NF и если в нем не содержатся независимые группы атрибутов, между которыми существует отношение «многие-ко-многим».
- **Пятая нормальная форма (5NF)** - Отношение находится в 5NF, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.
- **Шестая нормальная форма (6NF)** - Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным зависимостям соединения, т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6NF, также находится и в 5NF. Введена как обобщение пятой нормальной формы для хронологической базы данных.
- **Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF)** - Отношение находится в BCNF, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
- **Доменно-ключевая нормальная форма (DKNF)** - Отношение находится в DKNF, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.

### 4. В чем различия модульного и интеграциого тестирований?



**Модульное/компонентное тестирование (unit testing)** - процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.

Модульные тесты можно условно поделить на две группы:
- **тесты состояния (state based)**, проверяющие что вызываемый метод объекта отработал корректно, проверяя состояние тестируемого объекта после вызова метода.
- **тесты взаимодействия (interaction tests)**, в которых тестируемый объект производит манипуляции с другими объектами. Применяются, когда требуется удостовериться, что тестируемый объект корректно взаимодействует с другими объектами.

**Интеграционное тестирование (integration testing)** — это тестирование, проверяющие работоспособность двух или более модулей системы в совокупности — то есть нескольких объектов как единого блока. В тестах взаимодействия же тестируется конкретный, определенный объект и то, как именно он взаимодействует с внешними зависимостями.  

С технологической точки зрения интеграционное тестирование является количественным развитием модульного, поскольку так же, как и модульное тестирование, оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки на месте отсутствующих модулей. Основная разница между модульным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, определяют стратегию выбора входных данных и методов анализа.

### 5. Расскажите про принципы SOLID.

`SOLID` - аббревиатура пяти принципов ООП для наиболее эффективного написания программ.

**SOLID**:
- **S - Single Responsibility (Принцип единственной ответственности)**. Каждый класс должен отвечать только за одну операцию. Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие. Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.
- **O - Open-Closed (Принцип открытости-закрытости)**. Классы должны  быть  открыты для расширения, но закрыты для модификации. Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим. Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.
- **L — Liskov Substitution (Принцип подстановки Барбары Лисков)**. Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы. В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок. Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип. Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.
- **I — Interface Segregation (Принцип разделения интерфейсов)**. Не следует ставить клиент в зависимость от методов, которые он не использует. Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов. Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем. 
Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.
- **D — Dependency Inversion (Принцип инверсии зависимостей)**. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.  
Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента.  
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций  
Абстракции – представляют интерфейс, соединяющий два класса  
Детали = специфические характеристики работы инструмента  
Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом. Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.
